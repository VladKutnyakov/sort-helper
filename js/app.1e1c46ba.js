(function(){"use strict";var t={7388:function(t,e,i){var s=i(9963),n=i(6252);function r(t,e,i,s,r,o){return(0,n.wg)(),(0,n.j4)((0,n.LL)(r.layout))}const o={class:"default-layout"},l={class:"content"};function a(t,e,i,s,r,a){const u=(0,n.up)("Sidebar"),d=(0,n.up)("router-view"),c=(0,n.up)("Footer");return(0,n.wg)(),(0,n.iD)("div",o,[(0,n.Wm)(u,{items:r.items},null,8,["items"]),(0,n._)("div",l,[(0,n.Wm)(d)]),(0,n.Wm)(c)])}var u=i(3577);const d=(0,n._)("div",{class:"sidebar__title"}," Sort Helper ",-1),c={class:"sidebar__list"},m=["href"];function h(t,e,i,s,r,o){return(0,n.wg)(),(0,n.iD)("div",{class:(0,u.C_)(["sidebar",{sidebar_closed:!r.isOpened}])},[(0,n._)("div",{class:"sidebar__icon",onClick:e[0]||(e[0]=(...t)=>o.toggleSidebar&&o.toggleSidebar(...t))},[(0,n._)("div",{class:(0,u.C_)(["icon",[{icon__cross:r.isOpened},{icon__list:!r.isOpened}]])},null,2)]),d,(0,n._)("div",c,[((0,n.wg)(!0),(0,n.iD)(n.HY,null,(0,n.Ko)(i.items,(t=>((0,n.wg)(),(0,n.iD)("a",{key:t,href:t.link,class:"list__item",onClick:e[1]||(e[1]=(...t)=>o.toggleSidebar&&o.toggleSidebar(...t))},(0,u.zw)(t.title),9,m)))),128))])],2)}var p={name:"SideBar",props:{items:Array},data(){return{isOpened:!1}},methods:{toggleSidebar(){this.isOpened=!this.isOpened}}},b=i(3744);const _=(0,b.Z)(p,[["render",h]]);var S=_;const v={class:"footer"},f=(0,n.uE)('<div class="footer__contacts"><div class="contacts__author"> Кутняков Владислав 2022 г. </div><div class="contacts__socials"><a href="https://github.com/VladKutnyakov" target="_blank"><div class="socials__item socials__item-github"></div></a></div></div>',1),y=[f];function I(t,e,i,s,r,o){return(0,n.wg)(),(0,n.iD)("div",v,y)}var k={name:"Footer"};const w=(0,b.Z)(k,[["render",I]]);var g=w,j={name:"DefaultLayout",components:{Sidebar:S,Footer:g},data(){return{items:[{title:"Сортировка пузырьком",link:"#bubble-sort"},{title:"Сортировка выбором",link:"#selection-sort"},{title:"Сортировка вставками",link:"#insertion-sort"},{title:"Быстрая сортировка",link:"#quick-sort"}]}}};const F=(0,b.Z)(j,[["render",a]]);var x=F;const N={class:"empty-layout"},C={class:"content"};function O(t,e,i,s,r,o){const l=(0,n.up)("router-view");return(0,n.wg)(),(0,n.iD)("div",N,[(0,n._)("div",C,[(0,n.Wm)(l)])])}var W={name:"EmptyLayout"};const V=(0,b.Z)(W,[["render",O]]);var U=V,L={name:"App",components:{DefaultLayout:x,EmptyLayout:U},data(){return{layout:"DefaultLayout"}},watch:{$route(t){switch(t.name){case"NotFound":this.layout="EmptyLayout";break;default:this.layout="DefaultLayout";break}}}};const A=(0,b.Z)(L,[["render",r]]);var B=A,D=i(2201);const $={class:"home"};function M(t,e,i,s,r,o){const l=(0,n.up)("chart-block-bubble"),a=(0,n.up)("chart-block-selection"),u=(0,n.up)("chart-block-insertion"),d=(0,n.up)("chart-block-quick");return(0,n.wg)(),(0,n.iD)("div",$,[(0,n.Wm)(l),(0,n.Wm)(a),(0,n.Wm)(u),(0,n.Wm)(d)])}const Z=(0,n._)("sup",null,"2",-1),q=(0,n._)("code",null,[(0,n._)("pre",null,"function bubbleSort(array) {\n  for (let i = 0; i < array.length; i++) {\n    for (let j = 0; j < array.length; j++) {\n      if (array[j] > array[j + 1]) {\n        let temp = array[j]\n        array[j] = array[j + 1]\n        array[j + 1] = temp\n      }\n    }\n  }\n  return array\n}\n        ")],-1);function z(t,e,i,s,r,o){const l=(0,n.up)("chart-block");return(0,n.wg)(),(0,n.j4)(l,{id:"bubble-sort",itemsNumber:r.itemsNumber,coloredItems:r.coloredItems,delay:r.delay,isFinished:r.isFinished,onSortStart:o.bubbleSort,onSortStop:o.bubbleSortStop,onSortStep:o.bubbleSortStep,onOnShuffle:o.resetActiveItem},{title:(0,n.w5)((()=>[(0,n.Uk)(" Сортировка пузырьком ")])),description:(0,n.w5)((()=>[(0,n.Uk)(" Сортировка пузырьком — один из самых известных алгоритмов сортировки. Здесь нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале. Представленный алгоритм является простейшим, и может быть усовершенствован. ")])),complexity:(0,n.w5)((()=>[(0,n.Uk)(" O(n"),Z,(0,n.Uk)(") ")])),"source-code":(0,n.w5)((()=>[q])),_:1},8,["itemsNumber","coloredItems","delay","isFinished","onSortStart","onSortStop","onSortStep","onOnShuffle"])}const E={class:"chart-block"},P={class:"chart-block__title"},H={class:"chart-block__content"},T={class:"chart-block__info"},K={class:"info__btn-group"},Y=(0,n._)("div",{class:"btn__icon triangle"},null,-1),J=(0,n._)("div",{class:"btn__icon pause"},null,-1),Q={class:"info__description"},G={class:"info__complexity"},R=(0,n._)("div",{class:"complexity__title"}," Сложность: ",-1),X={class:"complexity__formula"},tt={class:"info__designation"},et=(0,n._)("div",{class:"designation__title"}," Обозначения: ",-1),it={class:"designation__color designation__color_blue"},st={class:"designation__color designation__color_red"},nt={class:"info__source-code"},rt={class:"chart-block__chart"};function ot(t,e,i,r,o,l){const a=(0,n.up)("app-button"),u=(0,n.up)("app-input-number"),d=(0,n.up)("app-spoiler"),c=(0,n.up)("chart");return(0,n.wg)(),(0,n.iD)("div",E,[(0,n._)("div",P,[(0,n.WI)(t.$slots,"title")]),(0,n._)("div",H,[(0,n._)("div",T,[(0,n._)("div",K,[(0,n.wy)((0,n.Wm)(a,{disabled:!i.isFinished,onClick:e[0]||(e[0]=t=>l.sortStart(t))},{default:(0,n.w5)((()=>[Y])),_:1},8,["disabled"]),[[s.F8,i.isFinished]]),(0,n.wy)((0,n.Wm)(a,{disabled:i.isFinished,onClick:e[1]||(e[1]=t=>l.sortStop(t))},{default:(0,n.w5)((()=>[J])),_:1},8,["disabled"]),[[s.F8,!i.isFinished]]),(0,n.Wm)(a,{disabled:!i.isFinished,onClick:e[2]||(e[2]=t=>l.sortStep(t))},{default:(0,n.w5)((()=>[(0,n.Uk)(" Шаг ")])),_:1},8,["disabled"]),(0,n.Wm)(a,{disabled:!i.isFinished,onClick:e[3]||(e[3]=t=>l.shuffleItems())},{default:(0,n.w5)((()=>[(0,n.Uk)(" Перемешать ")])),_:1},8,["disabled"]),(0,n.Wm)(u,{modelValue:o.itemsNumberLocal,"onUpdate:modelValue":e[4]||(e[4]=t=>o.itemsNumberLocal=t),maxValue:"50",minValue:"2",disabled:!i.isFinished},{default:(0,n.w5)((()=>[(0,n.Uk)(" Размер выборки ")])),_:1},8,["modelValue","disabled"]),(0,n.Wm)(u,{modelValue:o.delayLocal,"onUpdate:modelValue":e[5]||(e[5]=t=>o.delayLocal=t),maxValue:"10000",minValue:"1",disabled:!i.isFinished},{default:(0,n.w5)((()=>[(0,n.Uk)(" Задержка (мс) ")])),_:1},8,["modelValue","disabled"])]),(0,n._)("div",Q,[(0,n.WI)(t.$slots,"description")]),(0,n._)("div",G,[R,(0,n._)("span",X,[(0,n.WI)(t.$slots,"complexity")])]),(0,n._)("div",tt,[et,(0,n._)("div",it,[(0,n.Uk)(" Синий - "),(0,n.WI)(t.$slots,"designation-blue",{},(()=>[(0,n.Uk)(" Перебираемый элемент ")]))]),(0,n._)("div",st,[(0,n.Uk)(" Красный - "),(0,n.WI)(t.$slots,"designation-red",{},(()=>[(0,n.Uk)(" Заменяемый элемент ")]))])]),(0,n._)("div",nt,[(0,n.Wm)(d,null,{label:(0,n.w5)((()=>[(0,n.Uk)(" Исходный код (JavaScript) ")])),content:(0,n.w5)((()=>[(0,n.WI)(t.$slots,"source-code")])),_:3})])]),(0,n._)("div",rt,[(0,n.Wm)(c,{items:o.items,coloredItems:i.coloredItems},null,8,["items","coloredItems"])])])])}i(7658);const lt={class:"chart"};function at(t,e,i,s,r,o){const l=(0,n.up)("chart-item");return(0,n.wg)(),(0,n.iD)("div",lt,[((0,n.wg)(!0),(0,n.iD)(n.HY,null,(0,n.Ko)(i.items,((t,e)=>((0,n.wg)(),(0,n.j4)(l,{key:e,item:t,index:e,length:i.items.length,coloredItems:i.coloredItems},null,8,["item","index","length","coloredItems"])))),128))])}function ut(t,e,i,s,r,o){return(0,n.wg)(),(0,n.iD)("div",{class:(0,u.C_)(["chart__item",[{chart__item_red:i.coloredItems.red==i.index},{chart__item_blue:i.coloredItems.blue==i.index},{chart__item_green:i.coloredItems.green==i.index},{chart__item_yellow:i.coloredItems.yellow==i.index}]]),style:(0,u.j5)([{height:10*i.item+"px"},{width:o.itemWidth+"px"}])},[(0,n._)("div",{class:"item__pointer",style:(0,u.j5)([{bottom:o.pointerBottom+"px"},{left:o.pointerLeft+"px"},{width:o.pointerSize+"px"},{height:o.pointerSize+"px"}])},null,4),(0,n._)("div",{class:"item__value",style:(0,u.j5)([{bottom:o.valueBottom+"px"},{left:o.valueLeft+"px"},{"font-size":o.valueFontSize+"px"}])},(0,u.zw)(i.item),5)],6)}var dt={name:"ChartItem",props:{item:Number,index:Number,length:Number,coloredItems:Object},computed:{itemWidth(){const t=Math.round(100/this.length);return t<3?3:t},pointerBottom(){return Math.round(1.5*-this.pointerSize)},pointerLeft(){return Math.round(-Math.abs(this.itemWidth-this.pointerSize)/2)},pointerSize(){const t=Math.round(this.itemWidth);return t<8?8:t},valueBottom(){return Math.round(2.5*-this.valueFontSize)},valueLeft(){return this.item>9?Math.round(-Math.abs(this.itemWidth-this.valueFontSize/1.5)):Math.round(-Math.abs(this.itemWidth-this.valueFontSize/2))},valueFontSize(){const t=Math.round(1.5*this.itemWidth);return t<12?12:t}}};const ct=(0,b.Z)(dt,[["render",ut]]);var mt=ct,ht={name:"Chart",components:{ChartItem:mt},props:{items:Array,coloredItems:Object}};const pt=(0,b.Z)(ht,[["render",at]]);var bt=pt;const _t={class:"btn"};function St(t,e,i,s,r,o){return(0,n.wg)(),(0,n.iD)("button",_t,[(0,n.WI)(t.$slots,"default")])}var vt={name:"AppButton"};const ft=(0,b.Z)(vt,[["render",St]]);var yt=ft;const It={class:"spoiler__content"};function kt(t,e,i,r,o,l){return(0,n.wg)(),(0,n.iD)("div",{class:(0,u.C_)(["spoiler",{spoiler_active:o.isActive}])},[(0,n._)("div",{class:"spoiler__label",onClick:e[0]||(e[0]=t=>l.toggleSpoiler())},[(0,n.WI)(t.$slots,"label")]),(0,n.wy)((0,n._)("div",It,[(0,n.WI)(t.$slots,"content")],512),[[s.F8,o.isActive]])],2)}var wt={name:"AppSpoiler",data(){return{isActive:!1}},methods:{toggleSpoiler(){return this.isActive=!this.isActive}}};const gt=(0,b.Z)(wt,[["render",kt]]);var jt=gt;const Ft={class:"input-number__label"},xt={class:"input-number__field"},Nt=["value","disabled"],Ct={class:"input-number__btn-group"},Ot=(0,n._)("div",{class:"input-number__btn-increase"},null,-1),Wt=[Ot],Vt=(0,n._)("div",{class:"input-number__btn-decrease"},null,-1),Ut=[Vt];function Lt(t,e,i,s,r,o){return(0,n.wg)(),(0,n.iD)("div",{class:(0,u.C_)(["input-number",{"input-number_disabled":i.disabled}])},[(0,n._)("div",Ft,[(0,n.WI)(t.$slots,"default")]),(0,n._)("div",xt,[(0,n._)("input",{class:"field__input",type:"number",value:i.modelValue,disabled:i.disabled,onChange:e[0]||(e[0]=t=>o.handleInput(t))},null,40,Nt),(0,n._)("div",Ct,[(0,n._)("div",{class:(0,u.C_)(["input-number__btn",{"input-number__btn_disabled":i.disabled||r.value>=i.maxValue}]),onClick:e[1]||(e[1]=(...t)=>o.increaseNubmer&&o.increaseNubmer(...t))},Wt,2),(0,n._)("div",{class:(0,u.C_)(["input-number__btn",{"input-number__btn_disabled":i.disabled||r.value<=i.minValue}]),onClick:e[2]||(e[2]=(...t)=>o.decreaseNubmer&&o.decreaseNubmer(...t))},Ut,2)])])],2)}var At={name:"AppInputNumber",props:{modelValue:[Number,String],maxValue:[Number,String],minValue:[Number,String],disabled:Boolean},data(){return{value:this.modelValue}},methods:{increaseNubmer(){this.disabled||(this.value++,this.value>this.maxValue&&(this.value=this.maxValue),this.$emit("update:modelValue",this.value))},decreaseNubmer(){this.disabled||(this.value--,this.value<this.minValue&&(this.value=this.minValue),this.$emit("update:modelValue",this.value))},handleInput(t){this.value=parseInt(t.target.value)||null,this.value>this.maxValue&&(this.value=this.maxValue),this.value<this.minValue&&(this.value=this.minValue),this.$emit("update:modelValue",this.value)}}};const Bt=(0,b.Z)(At,[["render",Lt]]);var Dt=Bt,$t={name:"ChartBlock",components:{Chart:bt,AppButton:yt,AppSpoiler:jt,AppInputNumber:Dt},props:{itemsNumber:Number,coloredItems:Object,delay:Number,isFinished:Boolean,step:Object},data(){return{items:[],itemsNumberLocal:this.itemsNumber,delayLocal:this.delay}},watch:{itemsNumberLocal(){this.fillItemsArray()}},methods:{shuffleItems(){this.items=this.items.map((t=>({value:t,sort:Math.random()}))).sort(((t,e)=>t.sort-e.sort)).map((({value:t})=>t)),this.$emit("onShuffle")},sortStart(){this.$emit("sortStart",this.items,this.delayLocal)},sortStop(){this.$emit("sortStop")},sortStep(){this.$emit("sortStep",this.items)},fillItemsArray(){this.items=[];for(let t=0;t<this.itemsNumberLocal;t++)this.items.push(t+1)}},created(){this.fillItemsArray()}};const Mt=(0,b.Z)($t,[["render",ot]]);var Zt=Mt,qt={name:"ChartBlockBubble",components:{ChartBlock:Zt},data(){return{coloredItems:{red:null,blue:null},step:{i:0,j:0},isFinished:!0,itemsNumber:30,delay:20}},methods:{resetActiveItem(){this.coloredItems={red:null,blue:null},this.step={i:0,j:0}},sleep(t){return new Promise((e=>{setTimeout(e,t)}))},async bubbleSort(t,e){this.isFinished=!1;while(!this.isFinished)this.bubbleSortStep(t),await this.sleep(e)},bubbleSortStop(){this.isFinished=!0},bubbleSortStep(t){if(this.coloredItems.blue=this.step.j,t[this.step.j]>t[this.step.j+1]){this.coloredItems.red=this.step.j+1;let e=t[this.step.j];t[this.step.j]=t[this.step.j+1],t[this.step.j+1]=e}this.step.j++>=t.length&&(this.step.j=0,this.step.i++>=t.length&&this.bubbleSortStop())}}};const zt=(0,b.Z)(qt,[["render",z]]);var Et=zt;const Pt=(0,n._)("sup",null,"2",-1),Ht=(0,n._)("code",null,[(0,n._)("pre",null,"function selectionSort(array) {\n    for (let i = 0; i < array.length; i++) {\n        let min = i\n        for (let j = i + 1; j < array.length; j++) {\n            if (array[min] > array[j]) {\n                min = j\n            }\n        }\n        if (i != min) {\n          let temp = array[i]\n          array[i] = array[min]\n          array[min] = temp\n        }\n    }\n}\n        ")],-1);function Tt(t,e,i,s,r,o){const l=(0,n.up)("chart-block");return(0,n.wg)(),(0,n.j4)(l,{id:"selection-sort",itemsNumber:r.itemsNumber,coloredItems:r.coloredItems,delay:r.delay,isFinished:r.isFinished,onSortStart:o.selectionSort,onSortStop:o.selectionSortStop,onSortStep:o.selectionSortStep,onOnShuffle:o.resetActiveItem},{title:(0,n.w5)((()=>[(0,n.Uk)(" Сортировка выбором ")])),description:(0,n.w5)((()=>[(0,n.Uk)(" Сортировка выбором является одним из простейших алгоритмов. Его суть — за каждый проход по массиву выбрать минимальный элемент (для сортировки по возрастанию) и поменять его местами с первым элементом в еще не отсортированном участке массива, тем самым уменьшив длину этого участка на один, и так до тех пор пока не будут отсортированы все элементы. ")])),complexity:(0,n.w5)((()=>[(0,n.Uk)(" O(n"),Pt,(0,n.Uk)(") ")])),"source-code":(0,n.w5)((()=>[Ht])),_:1},8,["itemsNumber","coloredItems","delay","isFinished","onSortStart","onSortStop","onSortStep","onOnShuffle"])}var Kt={name:"ChartBlockSelection",components:{ChartBlock:Zt},data(){return{coloredItems:{red:null,blue:null},step:{i:0,j:1},isFinished:!0,itemsNumber:30,delay:20,minItemIndex:null}},methods:{resetActiveItem(){this.coloredItems={red:null,blue:null},this.minItemIndex=null,this.step={i:0,j:1}},sleep(t){return new Promise((e=>{setTimeout(e,t)}))},async selectionSort(t,e){this.isFinished=!1;while(!this.isFinished)this.selectionSortStep(t),await this.sleep(e)},selectionSortStop(){this.isFinished=!0},selectionSortStep(t){if(this.coloredItems.blue=this.step.j,this.minItemIndex||(this.minItemIndex=this.step.i),t[this.minItemIndex]>t[this.step.j]&&(this.minItemIndex=this.step.j),this.step.j++,this.step.j>=t.length){if(this.step.j=this.step.i+1,this.step.i!=this.minItemIndex){this.coloredItems.red=this.minItemIndex;let e=t[this.minItemIndex];t[this.minItemIndex]=t[this.step.i],t[this.step.i]=e}this.step.i++,this.minItemIndex=this.step.i,this.step.i>=t.length&&this.selectionSortStop()}}}};const Yt=(0,b.Z)(Kt,[["render",Tt]]);var Jt=Yt;const Qt=(0,n._)("sup",null,"2",-1),Gt=(0,n._)("code",null,[(0,n._)("pre",null,"for (let i = 1, l = array.length; i < l; i++) {\n    const current = array[i]\n    let j = i\n    while (j > 0 && array[j - 1] > current) {\n        array[j] = array[j - 1]\n        j--\n    }\n    array[j] = current\n}\n        ")],-1);function Rt(t,e,i,s,r,o){const l=(0,n.up)("chart-block");return(0,n.wg)(),(0,n.j4)(l,{id:"insertion-sort",itemsNumber:r.itemsNumber,coloredItems:r.coloredItems,delay:r.delay,isFinished:r.isFinished,onSortStart:o.insertionSort,onSortStop:o.insertionSortStop,onSortStep:o.insertionSortStep,onOnShuffle:o.resetActiveItem},{title:(0,n.w5)((()=>[(0,n.Uk)(" Сортировка вставками ")])),description:(0,n.w5)((()=>[(0,n.Uk)(" Сортировка вставками — один из простейших алгоритмов сортировки. Суть его заключается в том, что в цикле один за другим выбираются элементы массива и сравниваются с элементами, стоящими перед ними, до тех пор пока не будет найдет элемент, меньший текущего, или мы не дойдем до начала массива. Перед ним мы и вставляем текущий, для этого предварительно сдвинув все элементы, которые оказались больше текущего, в сторону увеличения на один индекс. ")])),complexity:(0,n.w5)((()=>[(0,n.Uk)(" O(n"),Qt,(0,n.Uk)(") ")])),"source-code":(0,n.w5)((()=>[Gt])),_:1},8,["itemsNumber","coloredItems","delay","isFinished","onSortStart","onSortStop","onSortStep","onOnShuffle"])}var Xt={name:"ChartBlockInsertion",components:{ChartBlock:Zt},data(){return{coloredItems:{red:null,blue:null},step:{i:1,j:0},isFinished:!0,itemsNumber:30,delay:20,isLowerItemFound:!0,currentItem:null}},methods:{resetActiveItem(){this.coloredItems={red:null,blue:null},this.isLowerItemFound=!0,this.currentItem=null,this.step={i:1,j:0}},sleep(t){return new Promise((e=>{setTimeout(e,t)}))},async insertionSort(t,e){this.isFinished=!1;while(!this.isFinished)this.insertionSortStep(t),await this.sleep(e)},insertionSortStop(){this.isFinished=!0},insertionSortStep(t){this.step.i<t.length?(this.isLowerItemFound&&(this.coloredItems.blue=this.step.i,this.currentItem=t[this.step.i],this.step.j=this.step.i,this.isLowerItemFound=!1),this.step.j>0&&t[this.step.j-1]>this.currentItem?(this.coloredItems.red=this.step.j,t[this.step.j]=t[this.step.j-1],this.step.j--):(this.coloredItems.red=this.step.j,t[this.step.j]=this.currentItem,this.step.i++,this.isLowerItemFound=!0)):this.insertionSortStop()}}};const te=(0,b.Z)(Xt,[["render",Rt]]);var ee=te;const ie=(0,n._)("br",null,null,-1),se=(0,n._)("i",null,"sort()",-1),ne=(0,n._)("code",null,[(0,n._)("pre",null,"function quickSort(array, start, end) {\n  if (start === undefined) {\n    start = 0\n    end = array.length - 1\n  } else if (start >= end) {\n    return array\n  }\n  let rStart = start\n  let rEnd = end\n  let pivot = array[Math.floor(Math.random() * (end - start + 1) + start)]\n  while (start < end) {\n    while (array[start] <= pivot)\n      start++\n    while (array[end] > pivot)\n      end--\n    if (start < end) {\n      let temp = array[start]\n      array[start] = array[end]\n      array[end] = temp\n    }\n  }\n  quickSort(array, rStart, start - 1)\n  quickSort(array, start, rEnd)\n}\n        ")],-1);function re(t,e,i,s,r,o){const l=(0,n.up)("chart-block");return(0,n.wg)(),(0,n.j4)(l,{id:"quick-sort",itemsNumber:r.itemsNumber,coloredItems:r.coloredItems,delay:r.delay,isFinished:r.isFinished,onSortStart:o.quickSort,onSortStop:o.quickSortStop,onSortStep:o.quickSortStep,onOnShuffle:o.resetActiveItem},{title:(0,n.w5)((()=>[(0,n.Uk)(" Быстрая сортировка ")])),description:(0,n.w5)((()=>[(0,n.Uk)(" Быстрая сортировка — это “разделяй и властвуй” алгоритм в стиле “сортировка слиянием”. Основная идея заключается в том, чтобы найти опорный элемент в массиве для сравнения с остальными частями, затем сдвигать элементы так, чтобы все части перед опорным элементом были меньше его, а все элементы после опорного были больше его. После этого рекурсивно выполнить ту же операцию на элементы до и после опорного. "),ie,(0,n.Uk)(" В языке JavaScript стандартный метод сортировки "),se,(0,n.Uk)(" реализует алгоритм быстрой сортировки. ")])),complexity:(0,n.w5)((()=>[(0,n.Uk)(" O(n × log n) ")])),"source-code":(0,n.w5)((()=>[ne])),_:1},8,["itemsNumber","coloredItems","delay","isFinished","onSortStart","onSortStop","onSortStep","onOnShuffle"])}var oe={name:"ChartBlockQuick",components:{ChartBlock:Zt},data(){return{coloredItems:{red:null,blue:null,green:null},step:{i:0,j:1},isFinished:!0,itemsNumber:30,delay:20,minItemIndex:null}},methods:{resetActiveItem(){this.coloredItems={red:null,blue:null,green:null},this.minItemIndex=null,this.step={i:0,j:1}},sleep(t){return new Promise((e=>{setTimeout(e,t)}))},async quickSort(t,e){this.isFinished=!1;while(!this.isFinished)this.quickSortStep(t),await this.sleep(e)},quickSortStop(){this.isFinished=!0},quickSortStep(t,e,i){if(void 0===e)e=0,i=t.length-1;else if(e>=i)return this.isFinished=!0,t;let s=e,n=i,r=t[Math.floor(Math.random()*(i-e+1)+e)];while(e<i){while(t[e]<=r)e++;while(t[i]>r)i--;if(e<i){let s=t[e];t[e]=t[i],t[i]=s}}this.quickSortStep(t,s,e-1),this.quickSortStep(t,e,n)}}};const le=(0,b.Z)(oe,[["render",re]]);var ae=le,ue={name:"Home",components:{ChartBlockBubble:Et,ChartBlockSelection:Jt,ChartBlockInsertion:ee,ChartBlockQuick:ae}};const de=(0,b.Z)(ue,[["render",M]]);var ce=de;const me={class:"not-found"},he=(0,n._)("div",{class:"not-found__code"}," 404 ",-1),pe=(0,n._)("div",{class:"not-found__title"}," Страница не найдена ",-1),be=[he,pe];function _e(t,e,i,s,r,o){return(0,n.wg)(),(0,n.iD)("div",me,be)}var Se={};const ve=(0,b.Z)(Se,[["render",_e]]);var fe=ve;const ye=[{path:"/",name:"Home",meta:{title:"Визуализация алгоритмов сортировки"},component:ce},{path:"/:pathMatch(.*)*",name:"NotFound",meta:{title:"Страница не найдена"},component:fe}],Ie=(0,D.p7)({history:(0,D.PO)("/sort-helper/"),routes:ye});Ie.afterEach((t=>{(0,n.Y3)((()=>{document.title=t.meta.title||"Sort Helper"}))}));var ke=Ie;(0,s.ri)(B).use(ke).mount("#app")}},e={};function i(s){var n=e[s];if(void 0!==n)return n.exports;var r=e[s]={exports:{}};return t[s](r,r.exports,i),r.exports}i.m=t,function(){var t=[];i.O=function(e,s,n,r){if(!s){var o=1/0;for(d=0;d<t.length;d++){s=t[d][0],n=t[d][1],r=t[d][2];for(var l=!0,a=0;a<s.length;a++)(!1&r||o>=r)&&Object.keys(i.O).every((function(t){return i.O[t](s[a])}))?s.splice(a--,1):(l=!1,r<o&&(o=r));if(l){t.splice(d--,1);var u=n();void 0!==u&&(e=u)}}return e}r=r||0;for(var d=t.length;d>0&&t[d-1][2]>r;d--)t[d]=t[d-1];t[d]=[s,n,r]}}(),function(){i.d=function(t,e){for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})}}(),function(){i.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"===typeof window)return window}}()}(),function(){i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)}}(),function(){var t={143:0};i.O.j=function(e){return 0===t[e]};var e=function(e,s){var n,r,o=s[0],l=s[1],a=s[2],u=0;if(o.some((function(e){return 0!==t[e]}))){for(n in l)i.o(l,n)&&(i.m[n]=l[n]);if(a)var d=a(i)}for(e&&e(s);u<o.length;u++)r=o[u],i.o(t,r)&&t[r]&&t[r][0](),t[r]=0;return i.O(d)},s=self["webpackChunksort_helper"]=self["webpackChunksort_helper"]||[];s.forEach(e.bind(null,0)),s.push=e.bind(null,s.push.bind(s))}();var s=i.O(void 0,[998],(function(){return i(7388)}));s=i.O(s)})();
//# sourceMappingURL=app.1e1c46ba.js.map